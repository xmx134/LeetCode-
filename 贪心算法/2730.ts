// 2730. 找到最长的半重复子字符串
// 给你一个下标从 0 开始的字符串 s ，这个字符串只包含 0 到 9 的数字字符。
// 如果一个字符串 t 中至多有一对相邻字符是相等的，那么称这个字符串 t 是 半重复的 。
// 例如，"0010" 、"002020" 、"0123" 、"2002" 和 "54944" 是半重复字符串，
// 而 "00101022" （相邻的相同数字对是 00 和 22）和 "1101234883" （相邻的相同数字对是 11 和 88）
// 不是半重复字符串。
// 请你返回 s 中最长半重复子字符串的长度。
// 思路：
// 利用贪心算法处理问题，遍历整个字符串，遇到两对重复字符串前，记录整体遍历字符串长度。
// 遇到两对重复字符串后，left指针往后滑动到第一队重复字符串的后一位，也就是point的位置，重复流程。
// 判断哪个字符串长度是最大值。
// 核心：
// Math.max()方法是贪心算法的核心，每次遇到两个重复子字符串时，使用此方法记录下当前遍历长度。
// 当无法触发两个重复子字符串或者在字符串后半部分不触发遇到两个重复子字符串时，
// 再记录下从i到left的长度，与之前记录的值进行对比。
function longestSemiRepetitiveSubstring(s: string): number {
  if (s.length < 3) return s.length
  let i: number = 0
  let point: number = 0
  let temp: number = 0
  let times: number = 0
  let left: number = 0
  while (i < s.length) {
    if (s[i] === s[i - 1]) {
      times++
      if (times === 2) {
        temp = Math.max(temp, i - left)
        left = point
        times--
      }
      point = i
    }
    i++
  }
  return Math.max(temp, i - left)
}

// 贪心算法的基本概念
// 定义：贪心算法是一种在每一步选择中都采取当前状态下的最优决策（即局部最优解），
// 并且期望通过这些局部最优解的组合来达到全局最优解的算法策略。它不考虑整体的最优解是如何得到的，
// 而是从局部最优的角度出发，逐步构建解决方案。
// 示例说明：比如在找零问题中，假设有面值为 10 元、5 元、1 元的货币，要为顾客找零 16 元。
// 贪心算法的思路是，每次都优先选择面值最大的货币，即先选择 1 张 10 元，剩下 6 元，
// 再选择 1 张 5 元，剩下 1 元，最后选择 1 张 1 元，这样总共用了 3 张货币完成找零。
// 贪心算法的适用场景
// 活动安排问题：
// 问题描述：假设有一系列活动，每个活动都有开始时间和结束时间，要求在有限的时间内安排尽可能多的活动。
// 贪心策略：按照活动结束时间的先后顺序对活动进行排序。每次选择结束时间最早的活动，
// 这样可以为后续活动留出尽可能多的时间。例如，有活动 A（1, 3）、活动 B（2, 4）、活动 C（3, 6）、
// 活动 D（4, 7），这里括号内的数字分别表示活动的开始时间和结束时间。
// 按照结束时间排序后为 A、B、C、D。首先选择 A，因为它结束最早，然后在 A 结束后的时间里选择 B，
// 以此类推，最终可以安排 A、B 这两个活动。
// 背包问题（部分情况）：
// 问题描述：有一个容量为 C 的背包和 n 个物品，每个物品都有自己的重量和价值，
// 要求在不超过背包容量的情况下，装入背包的物品价值总和最大。
// 贪心策略（部分情况）：在物品可以分割的情况下（称为部分背包问题），
// 可以按照物品的价值密度（价值 / 重量）从高到低对物品进行排序。
// 每次优先选择价值密度最高的物品放入背包，直到背包无法再放入任何物品。
// 例如，背包容量为 5 千克，有物品 A（2 千克，价值 3 元）、物品 B（3 千克，价值 4 元），
// 物品 A 的价值密度为 1.5 元 / 千克，物品 B 的价值密度为 4/3 元 / 千克。先选择物品 A，
// 放入 2 千克后，背包还剩 3 千克，再放入物品 B 的 3 千克，这样背包中物品的总价值为 3 + 4 = 7 元。
// 哈夫曼编码问题：
// 问题描述：给定一组字符及其出现的频率，要为这些字符构造一种编码方式，使得编码后的总长度最短。
// 贪心策略：每次选择频率最低的两个节点（可以是字符节点或者合并后的节点）合并成一个新节点，
// 新节点的频率为这两个节点频率之和。重复这个过程，直到构建出一棵哈夫曼树。在哈夫曼树上，
// 从根节点到叶子节点的路径上的 0 和 1 序列就是每个字符的编码。例如，有字符 A（频率为 4）、
// B（频率为 3）、C（频率为 2）、D（频率为 1）。首先合并 C 和 D，得到一个新节点，
// 频率为 3，然后再合并这个新节点和 B，得到频率为 6 的节点，最后合并这个节点和 A，构建出哈夫曼树。
// 从树中可以得到 A 的编码为 0，B 的编码为 10，C 的编码为 110，D 的编码为 111，
// 这种编码方式可以使总编码长度最短。
// 贪心算法的步骤
// 问题分析：明确问题的目标和约束条件。例如，在活动安排问题中，目标是安排最多的活动，
// 约束条件是活动的时间不能重叠；在背包问题中，目标是使背包内物品价值最大，约束条件是背包容量有限。
// 确定贪心策略：根据问题的特点，找到一个合理的贪心策略。这通常需要对问题进行深入理解和分析，
// 并且有时候需要通过数学证明或者经验来验证策略的合理性。例如，在找零问题中，
// 贪心策略是优先选择面值大的货币；在活动安排问题中，贪心策略是优先选择结束时间早的活动。
// 按照贪心策略逐步构建解决方案：根据确定的贪心策略，
// 对问题的输入数据（如活动列表、物品列表等）进行处理。通常需要对数据进行排序或者其他预处理操作，
// 然后按照贪心策略逐个选择元素或者执行操作，直到满足问题的终止条件。例如，在背包问题中，
// 按照价值密度排序后，逐个将物品放入背包，直到背包容量不足；在活动安排问题中，按照结束时间排序后，
// 逐个选择活动，直到没有合适的活动可以选择。
// 验证全局最优性（如果可能）：对于一些简单的问题，
// 可以通过数学证明或者简单的推理来验证贪心算法得到的解是全局最优解。但对于很多复杂的问题，
// 贪心算法可能无法保证得到全局最优解，此时需要评估贪心算法得到的解与最优解的接近程度
// （例如通过与其他算法得到的最优解进行对比或者通过理论分析误差范围）。
// 贪心算法的局限性
// 不能保证全局最优性：在很多复杂的问题中，贪心算法由于只考虑局部最优，可能会错过真正的全局最优解。
// 例如，在旅行商问题（TSP）中，即一个推销员要访问所有城市并回到起始城市，要求路程最短。
// 如果采用贪心算法，每次选择距离当前城市最近的城市作为下一个访问城市，可能会陷入局部最优路径，
// 而无法找到全局最短路径。
// 对问题结构的依赖性强：贪心算法的有效性很大程度上依赖于问题本身的结构和性质。
// 只有当问题具有某种特殊的结构（如可以证明局部最优解的组合能够导致全局最优解）时，
// 贪心算法才能发挥良好的作用。如果问题的结构不符合贪心算法的要求，使用贪心算法可能会得到很差的结果。
